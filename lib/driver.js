// Generated by CoffeeScript 1.4.0
(function() {
  var DBI, PostgresDriver, loglet, pg,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  pg = require('pg');

  DBI = require('easydbi');

  loglet = require('loglet');

  PostgresDriver = (function(_super) {

    __extends(PostgresDriver, _super);

    PostgresDriver.pool = false;

    PostgresDriver.id = 0;

    function PostgresDriver(options) {
      this.options = options;
      PostgresDriver.__super__.constructor.call(this, this.options);
      this.connstr = this.makeConnStr(this.options);
    }

    PostgresDriver.prototype.makeConnStr = function(options) {
      return options;
    };

    PostgresDriver.prototype.connect = function(cb) {
      var self,
        _this = this;
      loglet.debug("PostgresDriver.connect", this.options);
      self = this;
      this.inner = new pg.Client(this.connstr);
      return this.inner.connect(function(err) {
        if (err) {
          return cb(err);
        } else {
          loglet.debug('PostgresDriver.connect:OK', self.id);
          return cb(null, self);
        }
      });
    };

    PostgresDriver.prototype.isConnected = function() {
      var val;
      val = this.inner instanceof pg.Client;
      loglet.debug("PostgresDriver.isConnected", this.inner instanceof pg.Client);
      return val;
    };

    PostgresDriver.prototype.query = function(key, args, cb) {
      var i, keyGen, _ref;
      loglet.debug("PostgresDriver.query", key, args);
      try {
        i = 0;
        keyGen = function() {
          i = i + 1;
          return "$" + i;
        };
        _ref = DBI.queryHelper.arrayify(key, args, {
          key: keyGen
        }), key = _ref[0], args = _ref[1];
        return this._query(key, args, cb);
      } catch (e) {
        return cb(e);
      }
    };

    PostgresDriver.prototype._query = function(stmt, args, cb) {
      var _this = this;
      loglet.debug("PostgresDriver._query", stmt, args);
      return this.inner.query(stmt, args, function(err, result) {
        if (err) {
          return cb(err);
        } else if (stmt.match(/^select/i)) {
          return cb(null, result.rows);
        } else {
          return cb(null);
        }
      });
    };

    PostgresDriver.prototype.exec = function(key, args, cb) {
      var i, keyGen, _ref;
      loglet.debug("PostgresDriver.exec", key, args);
      if (key === 'begin') {
        return this.begin(cb);
      } else if (key === 'commit') {
        return this.commit(cb);
      } else if (key === 'rollback') {
        return this.rollback(cb);
      } else {
        try {
          i = 0;
          keyGen = function() {
            i = i + 1;
            return "$" + i;
          };
          _ref = DBI.queryHelper.arrayify(key, args, {
            key: keyGen
          }), key = _ref[0], args = _ref[1];
          return this._query(key, args, cb);
        } catch (e) {
          return cb(e);
        }
      }
    };

    PostgresDriver.prototype.begin = function(cb) {
      return this.inner.query('BEGIN', cb);
    };

    PostgresDriver.prototype.commit = function(cb) {
      return this.inner.query('COMMIT', cb);
    };

    PostgresDriver.prototype.rollback = function(cb) {
      return this.inner.query('ROLLBACK', cb);
    };

    PostgresDriver.prototype.disconnect = function(cb) {
      try {
        this.inner.end();
        return cb(null);
      } catch (e) {
        return cb(e);
      }
    };

    PostgresDriver.prototype.close = function(cb) {
      try {
        this.inner.end();
        return cb(null);
      } catch (e) {
        return cb(e);
      }
    };

    return PostgresDriver;

  })(DBI.Driver);

  DBI.register('pg', PostgresDriver);

  module.exports = PostgresDriver;

}).call(this);
